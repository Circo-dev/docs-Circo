<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Circo</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Circo logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Circo</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introducing Circo</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../showcase/">Showcase</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../infotons/">Infoton Optimization</a></li><li><a class="tocitem" href="../plugindev/">Plugin development</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li><li><a class="tocitem" href="../troubleshooting/">Troubleshooting</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Circo-dev/Circo/blob/main/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><ul><li><a href="#CircoCore.Actor"><code>CircoCore.Actor</code></a></li><li><a href="#CircoCore.ActorId"><code>CircoCore.ActorId</code></a></li><li><a href="#CircoCore.Addr"><code>CircoCore.Addr</code></a></li><li><a href="#CircoCore.CircoContext"><code>CircoCore.CircoContext</code></a></li><li><a href="#CircoCore.EventSource"><code>CircoCore.EventSource</code></a></li><li><a href="#CircoCore.EventSourceDied"><code>CircoCore.EventSourceDied</code></a></li><li><a href="#CircoCore.Failure"><code>CircoCore.Failure</code></a></li><li><a href="#CircoCore.OnBecome"><code>CircoCore.OnBecome</code></a></li><li><a href="#CircoCore.OnDeath"><code>CircoCore.OnDeath</code></a></li><li><a href="#CircoCore.OnSpawn"><code>CircoCore.OnSpawn</code></a></li><li><a href="#CircoCore.Pos"><code>CircoCore.Pos</code></a></li><li><a href="#CircoCore.PostCode"><code>CircoCore.PostCode</code></a></li><li><a href="#CircoCore.SigTerm"><code>CircoCore.SigTerm</code></a></li><li><a href="#CircoCore.Subscribe"><code>CircoCore.Subscribe</code></a></li><li><a href="#CircoCore.Tokenized"><code>CircoCore.Tokenized</code></a></li><li><a href="#CircoCore.UnSubscribe"><code>CircoCore.UnSubscribe</code></a></li><li><a href="#Circo.onmigrate-Tuple{Actor, Any}"><code>Circo.onmigrate</code></a></li><li><a href="#CircoCore.addr-Tuple{Actor}"><code>CircoCore.addr</code></a></li><li><a href="#CircoCore.addr-Tuple{Any}"><code>CircoCore.addr</code></a></li><li><a href="#CircoCore.become-Union{Tuple{TMsg}, Tuple{TScheduler}, Tuple{CircoCore.AbstractService{TScheduler, TMsg}, Actor, Actor}} where {TScheduler, TMsg}"><code>CircoCore.become</code></a></li><li><a href="#CircoCore.box-Tuple{Any}"><code>CircoCore.box</code></a></li><li><a href="#CircoCore.box-Tuple{Actor}"><code>CircoCore.box</code></a></li><li><a href="#CircoCore.die-Tuple{Circo Service, Actor}"><code>CircoCore.die</code></a></li><li><a href="#CircoCore.fire-Union{Tuple{TEvent}, Tuple{Any, Actor, TEvent}} where TEvent&lt;:Event"><code>CircoCore.fire</code></a></li><li><a href="#CircoCore.getname-Tuple{Any, String}"><code>CircoCore.getname</code></a></li><li><a href="#CircoCore.isbaseaddress-Tuple{Addr}"><code>CircoCore.isbaseaddress</code></a></li><li><a href="#CircoCore.isnulladdr-Tuple{Addr}"><code>CircoCore.isnulladdr</code></a></li><li><a href="#CircoCore.onmessage-Tuple{Actor, Any, Any}"><code>CircoCore.onmessage</code></a></li><li><a href="#CircoCore.pos-Tuple{Actor}"><code>CircoCore.pos</code></a></li><li><a href="#CircoCore.redirect-Tuple{Addr, String}"><code>CircoCore.redirect</code></a></li><li><a href="#CircoCore.registername-Tuple{Circo Service, String, Addr}"><code>CircoCore.registername</code></a></li><li><a href="#CircoCore.send-Union{Tuple{TCore}, Tuple{TMsg}, Tuple{TScheduler}, Tuple{CircoCore.AbstractService{TScheduler, TMsg}, Any, Addr, Any}} where {TScheduler, TMsg, TCore}"><code>CircoCore.send</code></a></li><li><a href="#CircoCore.spawn-Tuple{Circo Service, Actor}"><code>CircoCore.spawn</code></a></li><li><a href="#CircoCore.traits-Tuple{Type{&lt;:Actor}}"><code>CircoCore.traits</code></a></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Items from CircoCore are reexported thus available directly from Circo.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="CircoCore.Actor" href="#CircoCore.Actor"><code>CircoCore.Actor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Actor{TCoreState}</code></pre><p>Supertype of all actors.</p><p>Subtypes must be mutable and must provide a field <code>core::TCoreState</code> that can remain undefined after creation.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">mutable struct DataHolder{TValue, TCore} &lt;: Actor{TCore}
    value::TValue
    core::TCore
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.ActorId" href="#CircoCore.ActorId"><code>CircoCore.ActorId</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ActorId</code></pre><p>A cluster-unique id that is randomly generated when the actor is spawned (first scheduled).</p><p><code>ActorId</code> is an alias to <code>UInt64</code> at the time, so it may pop up in error messages as such.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.Addr" href="#CircoCore.Addr"><code>CircoCore.Addr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Addr(postcode::PostCode, box::ActorId)
Addr(readable_address::String)
Addr()</code></pre><p>The full address of an actor.</p><p>When created without arguments, it will be the null address. See <a href="#CircoCore.isnulladdr-Tuple{Addr}"><code>isnulladdr()</code></a></p><p>If the referenced actor migrates to a different scheduler, messages sent to the old address will bounce back as <a href="@ref"><code>RecipientMoved</code></a> and the Addr must be updated manually.</p><p><strong>Examples</strong></p><p>Addr(&quot;192.168.1.11:24721&quot;, 0xbc6ac81fc7e4ea2)</p><p>Addr(&quot;192.168.1.11:24721/bc6ac81fc7e4ea2&quot;)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.CircoContext" href="#CircoCore.CircoContext"><code>CircoCore.CircoContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CircoContext(;options...) &lt;: AbstractContext</code></pre><p>Store configuration, manage staging and run-time code optimizations for Circo.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.EventSource" href="#CircoCore.EventSource"><code>CircoCore.EventSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EventSource</code></pre><p>Trait for actors that can publish events.</p><p>Manages subscriptions and dispatches events. You need to add a field <code>eventdispatcher::Addr</code> to your actor to use this trait.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.EventSourceDied" href="#CircoCore.EventSourceDied"><code>CircoCore.EventSourceDied</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EventSourceDied</code></pre><p>SigTerm cause for terminating event dispatchers.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.Failure" href="#CircoCore.Failure"><code>CircoCore.Failure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Failure &lt;: Response end</code></pre><p><code>Failure</code> is a type of <code>Response</code> to a <code>Request</code> that fails to fulfill it.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.OnBecome" href="#CircoCore.OnBecome"><code>CircoCore.OnBecome</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OnBecome(reincarnation::Actor)</code></pre><p>Actor lifecycle message marking the <code>become()</code> action.</p><p><code>reincarnation</code> points to the new incarnation of the actor. <code>me</code> is scheduled at the delivery time of this message, <code>reincarnation</code> is not.</p><p>Exceptions thrown while handling <code>OnBecome</code><code>will propagate to the initiating</code>become` call.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.OnDeath" href="#CircoCore.OnDeath"><code>CircoCore.OnDeath</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OnDeath</code></pre><p>Actor lifecycle message to release resources when the actor dies (meaning unscheduled &quot;permanently&quot;).</p><p>The actor is still scheduled when this message is delivered, but no more messages will be delivered after this.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.OnSpawn" href="#CircoCore.OnSpawn"><code>CircoCore.OnSpawn</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OnSpawn</code></pre><p>Actor lifecycle message that marks the first scheduling of the actor, sent during spawning, before any other message.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">CircoCore.onmessage(me::MyActor, ::OnSpawn, service) = begin
    registername(service, &quot;MyActor&quot;, me) # Register this actor in the local name service
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.Pos" href="#CircoCore.Pos"><code>CircoCore.Pos</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pos(x::Real, y::Real, z::Real)
Pos(coords)</code></pre><p>A point in the 3D &quot;actor space&quot;.</p><p>You can access the coords by pos.x, pos.y, pos.z.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.PostCode" href="#CircoCore.PostCode"><code>CircoCore.PostCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PostCode</code></pre><p>A string that identifies a scheduler.</p><p><strong>Examples</strong></p><p>&quot;192.168.1.11:24721&quot;</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.SigTerm" href="#CircoCore.SigTerm"><code>CircoCore.SigTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SigTerm(cause=Nothing; exit=Nothing)</code></pre><p>Signal to terminate an actor.</p><p>The default handler terminates the actor without delay.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.Subscribe" href="#CircoCore.Subscribe"><code>CircoCore.Subscribe</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Subscribe(eventtype::Type, subscriber::Union{Actor, Addr}, filter::Union{Nothing, String, Function} = nothing)</code></pre><p>Message for subscribing to events of the given <code>eventtype</code>.</p><p>The subscription can be optionally filtered by a topic string or a predicate function. Filtering and subscription management will be done by the event dispatcher, which is a separate actor.</p><p><code>eventtype</code> must be concrete.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">    fs = getname(service, &quot;fs&quot;)
    send(service, me, fs, Subscribe(FSEvent, me, &quot;MODIFY&quot;))
    send(service, me, fs, Subscribe(FSEvent, me, event -&gt; event.path == &quot;test.txt&quot;))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.Tokenized" href="#CircoCore.Tokenized"><code>CircoCore.Tokenized</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Tokenized end</code></pre><p>Tokenized messages can be tracked automatically by the scheduler.</p><p>When an actor sends out a <a href="@ref"><code>Request</code></a>, a timeout will be set up to track the fulfillment of the request. When a <code>Response</code> with the same token is received, the timeout will be cancelled. See also: <a href="#CircoCore.send-Union{Tuple{TCore}, Tuple{TMsg}, Tuple{TScheduler}, Tuple{CircoCore.AbstractService{TScheduler, TMsg}, Any, Addr, Any}} where {TScheduler, TMsg, TCore}"><code>send</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.UnSubscribe" href="#CircoCore.UnSubscribe"><code>CircoCore.UnSubscribe</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Unsubscribe(subscriber::Addr, eventtype::Type)</code></pre><p>Message for unsubscribing from events of the given <code>eventtype</code>.</p><p>Cancels all subscriptions of the given <code>subscriber</code> for the given <code>eventtype</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.addr-Tuple{Actor}" href="#CircoCore.addr-Tuple{Actor}"><code>CircoCore.addr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addr(a::Actor)</code></pre><p>Return the address of the actor.</p><p>Call this on a spawned actor to get its address. Throws <code>UndefRefError</code> if the actor is not spawned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.addr-Tuple{Any}" href="#CircoCore.addr-Tuple{Any}"><code>CircoCore.addr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addr(entity)</code></pre><p>Return the address of entity.</p><p>The default implementation returns the <code>addr</code> field, allowing you to use your own structs with such fields as message targets.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.become-Union{Tuple{TMsg}, Tuple{TScheduler}, Tuple{CircoCore.AbstractService{TScheduler, TMsg}, Actor, Actor}} where {TScheduler, TMsg}" href="#CircoCore.become-Union{Tuple{TMsg}, Tuple{TScheduler}, Tuple{CircoCore.AbstractService{TScheduler, TMsg}, Actor, Actor}} where {TScheduler, TMsg}"><code>CircoCore.become</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">become(service, old::Actor, reincarnated::Actor)</code></pre><p>Reincarnates the <code>old</code> actor into <code>new</code>, meaning that <code>old</code> will be unscheduled, and <code>reincarnated</code> will be scheduled reusing the address of <code>old</code>.</p><p>The <code>onbecome</code> lifecycle callback will be called.</p><p>Note: As the name suggests, <code>become</code> is the Circonian way of behavior change.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.box-Tuple{Actor}" href="#CircoCore.box-Tuple{Actor}"><code>CircoCore.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box(a::Actor)</code></pre><p>Return the &#39;P.O. box&#39; of the spawned actor.</p><p>Call this on a spawned actor to get its id (aka box). Throws <code>UndefRefError</code> if the actor is not spawned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.box-Tuple{Any}" href="#CircoCore.box-Tuple{Any}"><code>CircoCore.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box(a::Addr)::ActorId</code></pre><p>Return the box of the address, that is the id of the actor.</p><p>When the actor migrates, its box remains the same, only the PostCode of the address changes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.die-Tuple{Circo Service, Actor}" href="#CircoCore.die-Tuple{Circo Service, Actor}"><code>CircoCore.die</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">die(service, me::Actor; exit=false)</code></pre><p>Permanently unschedule the actor from its current scheduler.</p><p>if <code>exit</code> is true and this is the last actor on its scheduler, the scheduler will be terminated.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.fire-Union{Tuple{TEvent}, Tuple{Any, Actor, TEvent}} where TEvent&lt;:Event" href="#CircoCore.fire-Union{Tuple{TEvent}, Tuple{Any, Actor, TEvent}} where TEvent&lt;:Event"><code>CircoCore.fire</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fire(service, me::Actor, event::Event)</code></pre><p>Fire an event on the actor to be delivered by the actor&#39;s eventdispatcher.</p><p>To fire an event, the actor must have a field <code>eventdispatcher::Addr</code>, which will be filled automatically.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.getname-Tuple{Any, String}" href="#CircoCore.getname-Tuple{Any, String}"><code>CircoCore.getname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function getname(service, name::String)::Union{Addr, Nothing}</code></pre><p>Return the registered name from the scheduler-local registry, or nothing.</p><p>See also: <a href="@ref"><code>NameQuery</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.isbaseaddress-Tuple{Addr}" href="#CircoCore.isbaseaddress-Tuple{Addr}"><code>CircoCore.isbaseaddress</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isbaseaddress(addr::Addr)::Bool</code></pre><p>Return true if <code>addr</code> is a base address, meaning it references a scheduler directly.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.isnulladdr-Tuple{Addr}" href="#CircoCore.isnulladdr-Tuple{Addr}"><code>CircoCore.isnulladdr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isnulladdr(a::Addr)</code></pre><p>Check if the given address is a null address, meaning that it points to &quot;nowhere&quot;, messages sent to it will be dropped.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.onmessage-Tuple{Actor, Any, Any}" href="#CircoCore.onmessage-Tuple{Actor, Any, Any}"><code>CircoCore.onmessage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onmessage(me::Actor, message, service)</code></pre><p>Actor callback to handle a message arriving at an actor.</p><p>Only the payload of the message is delivered, there is currently no way to access the infoton or the sender address. If you need a reply, include the sender address in the request.</p><p>Note: Do not forget to import it or use its qualified name to allow overloading!</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import CircoCore.onmessage

struct TestRequest
    replyto::Addr
end

struct TestResponse end

function onmessage(me::MyActor, message::TestRequest, service)
    send(service, me, message.replyto, TestResponse())
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.pos-Tuple{Actor}" href="#CircoCore.pos-Tuple{Actor}"><code>CircoCore.pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pos(a::Actor)::Pos</code></pre><p>return the current position of the actor.</p><p>Call this on a spawned actor to get its position. Throws <code>UndefRefError</code> if the actor is not spawned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.redirect-Tuple{Addr, String}" href="#CircoCore.redirect-Tuple{Addr, String}"><code>CircoCore.redirect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">redirect(addr::Addr, topostcode::PostCode):Addr</code></pre><p>Create a new Addr by replacing the postcode of the given one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.registername-Tuple{Circo Service, String, Addr}" href="#CircoCore.registername-Tuple{Circo Service, String, Addr}"><code>CircoCore.registername</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">registername(service, name::String, actor::Union{Addr,Actor})</code></pre><p>Register the given actor under the given name in the scheduler-local name registry.</p><p>Note that there is no need to unregister the name when migrating or dying</p><p><strong>TODO implement manual and auto-unregistration</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.send-Union{Tuple{TCore}, Tuple{TMsg}, Tuple{TScheduler}, Tuple{CircoCore.AbstractService{TScheduler, TMsg}, Any, Addr, Any}} where {TScheduler, TMsg, TCore}" href="#CircoCore.send-Union{Tuple{TCore}, Tuple{TMsg}, Tuple{TScheduler}, Tuple{CircoCore.AbstractService{TScheduler, TMsg}, Any, Addr, Any}} where {TScheduler, TMsg, TCore}"><code>CircoCore.send</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">send(service, sender::Actor, to::Addr, messagebody::Any; energy::Real = 1, timeout::Real = 2.0)</code></pre><p>Send a message from an actor to an another.</p><p>Part of the actor API, can be called from a lifecycle callback, providing the <code>service</code> you got.</p><p><code>messagebody</code> can be of any type, but a current limitation of inter-node communication is that the serialized form of <code>messagebody</code> must fit in an IPv4 UDP packet with ~100 bytes margin. The exact value depends on the MTU size of the network and changing implementation details, but 1380 bytes can be considered safe. You may be able to tune your system to get higher values.</p><p>If <code>messagebody</code> is a <code>Request</code>, a timeout will be set for the token of it. The <code>timeout</code> keyword argument can be used to control the deadline (seconds).</p><p><code>energy</code> sets the energy and sign of the Infoton attached to the message (if the infoton optimizer is running).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">const QUERY = &quot;The Ultimate Question of Life, The Universe, and Everything.&quot;

mutable struct MyActor &lt;: Actor{TCoreState}
    searcher::Addr
    core::CoreState
    MyActor() = new()
end

struct Start end

struct Search
    query::String
end

[...] # Spawn the searcher or receive its address


function CircoCore.onmessage(me::MyActor, message::Start, service)
    send(service,
            me,
            me.searcher,
            Search(QUERY, addr(me)))
end</code></pre><p><strong>Implementation</strong></p><p>Please note that <code>service</code> is always the last argument of lifecycle callbacks like <code>onmessage</code>. It&#39;s because <code>onmessage</code> is dynamically dispatched, and <code>service</code> provides no information about where to dispatch. (Only one service instance exists as of <code>v&quot;0.2.0&quot;</code>) Listing it at the end improves performance.</p><p>On the other hand, actor API endpoints like <code>send</code> are always statically dispatched, thus they can accept the service as their first argument, allowing the user to treat e.g. &quot;<code>spawn(service</code>&quot; as a single unit of thought and not forget to write out the ballast <code>service</code>.</p><p>Consistency is just as important as convenience. But performance is king.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.spawn-Tuple{Circo Service, Actor}" href="#CircoCore.spawn-Tuple{Circo Service, Actor}"><code>CircoCore.spawn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spawn(service, actor::Actor, [pos::Pos])::Addr</code></pre><p>Spawn the given actor on the scheduler represented by <code>service</code>, return the address of it.</p><p>Part of the actor API, can be called from a lifecycle callback, providing the <code>service</code> you got.</p><p>The <code>OnSpawn</code> message will be delivered to <code>actor</code> before this function returns.</p><p><strong>Examples</strong></p><p><strong>TODO: update this sample</strong></p><pre><code class="nohighlight hljs">mutable struct ListItem{TData, TCore} &lt;: Actor{TCore}
    data::TData
    next::Union{Nothing, Addr}
    core::TCore
    ListItem(data, core) = new{typeof(data), typeof(core)}(data, nothing, core)
end

struct Append{TData}
    value::TData
end

function CircoCore.onmessage(me::ListItem, message::Append, service)
    me.next = spawn(service, ListItem(message.value))
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CircoCore.traits-Tuple{Type{&lt;:Actor}}" href="#CircoCore.traits-Tuple{Type{&lt;:Actor}}"><code>CircoCore.traits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traits(::Type{&lt;:Actor}) = ()</code></pre><p>You can declare the traits of an actor by defining a method of this function.</p><p>Traits can handle messages in the name of the actor, helping to compose the behavior of the actor (See <a href="@ref"><code>ontraitmessage()</code></a>.).</p><p>E.g.: The EventSource trait handles the Subscribe and UnSubscribe messages automatically (among others). Anything can be a trait, but we recommend to use immutable structs.</p><p>Return a tuple of traits, either instantiated or not. Instantiated traits can hold values, while traits given as types will be instantiated without arguments.</p><p>Important: Traits <em>cannot</em> hold state. If a trait needs to store state in the actor you have to add fields to the actor manually.</p><p><strong>Examples</strong></p><p>struct DumpFieldTrait # Dumps a single field of the actor to stdout when the actor is dying.     fieldname::Symbol end</p><p>CircoCore.ontraitmessage(trait::DumpFieldTrait, me, ::OnDeath, service) = begin     println(&quot;¨trait.fieldname: getfield(me, trait.fieldname)&quot;) end</p><p>mutable struct MyActor &lt;: Actor{Any}     a     b     core     MyActor() = new(rand(Int8), rand(Int8)) end</p><p>CircoCore.traits(::Type{MyActor}) = (DumpFieldTrait(:a), DumpFieldTrait(:b))</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Circo.onmigrate-Tuple{Actor, Any}" href="#Circo.onmigrate-Tuple{Actor, Any}"><code>Circo.onmigrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onmigrate(me::Actor, service)</code></pre><p>Lifecycle callback that marks a successful migration.</p><p>It is called on the target scheduler, before any messages will be delivered.</p><p>Note: Do not forget to import it or use its qualified name to allow overloading!</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">function Circo.onmigrate(me::MyActor, service)
    @info &quot;Successfully migrated, registering a name on the new scheduler&quot;
    registername(service, &quot;MyActor&quot;, me)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Circo-dev/Circo/blob/f64b992daf603b6eee45c3c05978627ced88b390/src/Circo.jl#L22-L38">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plugindev/">« Plugin development</a><a class="docs-footer-nextpage" href="../troubleshooting/">Troubleshooting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 2 December 2022 14:26">Friday 2 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
